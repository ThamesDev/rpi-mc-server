#if 0
	shc Version 3.9.6, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f start-server.sh 
#endif

static  char data [] = 
#define      chk2_z	19
#define      chk2	((&data[2]))
	"\210\160\263\127\203\236\057\323\165\006\164\256\145\321\175\114"
	"\206\371\074\375\334"
#define      msg1_z	65
#define      msg1	((&data[32]))
	"\201\223\135\144\150\363\044\274\274\303\230\202\204\043\335\370"
	"\304\140\133\243\313\107\031\000\054\102\230\224\201\137\167\340"
	"\133\254\072\041\164\225\064\227\044\144\342\165\007\254\001\306"
	"\255\340\264\040\161\124\367\325\210\065\266\271\160\217\321\127"
	"\164\337\330\173\343\116\110\004\020\160\152\163\200\000\010"
#define      opts_z	1
#define      opts	((&data[100]))
	"\337"
#define      pswd_z	256
#define      pswd	((&data[138]))
	"\024\102\156\010\272\203\221\052\224\072\145\026\315\303\172\065"
	"\266\237\361\162\143\211\362\143\221\264\070\002\251\312\270\276"
	"\014\047\306\306\252\264\077\102\365\274\143\024\122\337\324\016"
	"\354\045\271\042\151\241\221\021\351\070\213\120\336\033\351\014"
	"\260\156\327\376\042\027\100\030\324\244\055\046\203\001\065\160"
	"\046\356\223\220\220\045\242\172\135\055\313\074\110\265\110\370"
	"\043\040\367\105\070\070\135\014\335\212\063\141\214\150\321\263"
	"\127\145\103\350\212\345\143\350\023\056\044\134\343\155\125\006"
	"\216\115\114\306\205\252\323\142\065\007\303\301\160\225\164\307"
	"\373\270\260\205\236\023\155\261\101\222\016\045\000\144\054\216"
	"\261\170\125\066\043\050\231\130\060\135\031\240\363\215\150\356"
	"\106\030\164\344\054\341\225\156\164\244\223\164\010\277\002\271"
	"\070\130\360\133\201\212\263\261\350\315\121\333\133\271\312\241"
	"\322\076\205\376\040\033\154\224\277\377\010\310\277\013\202\370"
	"\144\162\124\345\375\007\226\345\325\347\301\060\241\213\322\163"
	"\312\127\161\352\163\336\177\063\336\210\373\235\224\175\226\370"
	"\360\352\335\355\362\163\323\307\133\224\370\374\040\312\160\352"
	"\042\342\324\225\300\123\310\237\334\304\074\160\101\323\150\062"
	"\275\105\040\260\271\130\361\077\222\126\125\137\032\317\224\320"
	"\156\206\102\321\017\065\065\241\352\155\243\224\070\134\122\104"
	"\203\031\013\056\161\374\155\003\123\302\143\155\222\370\076\001"
	"\176\200\322"
#define      chk1_z	22
#define      chk1	((&data[444]))
	"\057\241\166\323\032\324\265\247\252\234\330\216\274\140\226\051"
	"\251\077\176\167\300\201\235\301\306\327"
#define      shll_z	10
#define      shll	((&data[468]))
	"\210\363\240\104\304\205\064\125\310\070\203\334"
#define      rlax_z	1
#define      rlax	((&data[478]))
	"\145"
#define      tst2_z	19
#define      tst2	((&data[479]))
	"\323\253\376\342\075\017\303\137\274\170\112\164\023\301\026\270"
	"\255\333\226\116\027\116\021"
#define      tst1_z	22
#define      tst1	((&data[506]))
	"\163\372\244\361\250\114\035\221\025\271\015\073\340\325\071\011"
	"\135\026\264\336\143\007\030\217\136\051\173\167\177"
#define      date_z	1
#define      date	((&data[531]))
	"\204"
#define      text_z	462
#define      text	((&data[643]))
	"\011\244\261\221\230\144\063\226\105\106\221\224\136\340\245\331"
	"\235\111\114\227\355\076\023\145\275\105\345\155\030\334\357\042"
	"\201\241\263\031\006\347\257\114\056\101\340\214\042\206\146\277"
	"\317\262\127\275\360\152\043\256\260\010\033\311\344\013\353\146"
	"\254\237\177\263\206\057\377\264\161\340\101\223\146\247\123\066"
	"\132\253\364\113\026\027\372\306\040\025\217\005\041\173\153\316"
	"\032\352\201\241\031\200\126\212\140\227\036\307\077\162\375\044"
	"\240\051\307\212\323\335\246\170\041\243\305\145\014\312\363\023"
	"\221\337\246\315\002\003\271\046\320\256\266\216\064\042\104\130"
	"\304\303\077\306\023\115\041\001\142\356\365\344\336\367\271\160"
	"\371\313\220\340\337\060\127\355\324\170\355\132\017\066\171\243"
	"\101\166\270\313\022\026\200\040\171\244\310\322\270\333\257\245"
	"\153\320\306\324\011\241\065\350\070\150\146\116\320\062\171\275"
	"\036\107\325\215\160\355\131\224\217\174\032\255\151\005\370\176"
	"\226\353\074\030\040\310\113\366\352\002\353\264\110\213\342\331"
	"\262\213\052\205\345\314\053\172\321\017\071\256\206\300\257\022"
	"\137\013\374\264\013\252\225\050\157\065\166\160\056\331\222\116"
	"\274\314\124\370\022\214\222\164\021\005\023\364\226\123\175\134"
	"\310\253\046\032\151\142\141\365\251\144\246\273\161\072\323\072"
	"\152\243\242\050\267\234\264\255\357\312\256\337\256\126\125\307"
	"\256\255\023\375\032\335\277\357\113\353\007\021\034\275\362\160"
	"\240\272\172\027\145\273\330\357\313\140\177\042\144\354\365\221"
	"\305\240\333\116\276\153\204\074\052\315\245\260\150\335\000\237"
	"\132\316\256\222\331\205\347\125\027\252\134\270\376\322\323\030"
	"\200\010\074\177\227\264\102\032\226\174\142\312\172\236\053\052"
	"\235\134\000\364\116\243\055\205\176\306\147\121\011\056\324\146"
	"\320\114\111\007\360\074\261\066\234\344\314\057\352\007\365\304"
	"\344\007\175\075\075\244\113\024\064\221\154\165\112\162\214\336"
	"\210\063\133\125\147\234\352\262\176\012\052\376\045\357\014\375"
	"\153\174\112\315\346\344\311\073\076\112\023\246\152\314\106\316"
	"\257\160\132\013\217\013\176\256\365\245\107\172\306\141\015\117"
	"\151\355\142\155\241\254\065\301\144\241\311\107\373\220\016\274"
	"\370\235\076\351\106\336\274\262\056\263\101\154\317\116\360\162"
	"\137\203\155\172\325\217\345\344\307\176\036\047\023\163\361\333"
	"\063\313\164\257\212\002\175\110\321\013\062\261\350\351\334\105"
	"\303\366\176\100\154\000\212\232\035\147\236\110\107\231\036\361"
	"\344\064\011\336\373\051\364\213\056\026\006\231\344\041\204\145"
	"\303\235\346\031\050\107\261\107\016\360\272\014\212\330\375\157"
	"\015\007\116\010\060\103\224\137\131\233\370\075\274\175\243\200"
	"\033\211\231\103\321\112\213\337"
#define      inlo_z	3
#define      inlo	((&data[1164]))
	"\155\260\231"
#define      xecc_z	15
#define      xecc	((&data[1167]))
	"\353\215\100\215\016\060\037\273\334\005\232\111\050\040\277\065"
	"\052\361"
#define      msg2_z	19
#define      msg2	((&data[1186]))
	"\306\364\306\127\154\350\051\370\366\116\127\135\023\152\340\006"
	"\114\160\043\150"
#define      lsto_z	1
#define      lsto	((&data[1205]))
	"\135"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
